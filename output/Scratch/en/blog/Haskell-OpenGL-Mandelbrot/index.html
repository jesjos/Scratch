<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        
        
        <meta name="keywords" content="Haskell, programming, functional, tutorial">
        
        <link rel="shortcut icon" type="image/x-icon" href="/Scratch/img/favicon.ico" />
        <link rel="stylesheet" type="text/css" href="/Scratch/assets/css/main.css" />
        <link rel="stylesheet" type="text/css" href="/Scratch/css/solarized.css" />
        <link rel="stylesheet" type="text/css" href="/Scratch/css/idc.css" />
        <link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>
        <link rel="alternate" type="application/rss+xml" title="RSS" href="http://feeds.feedburner.com/yannespositocomen"/>
        
        <link rel="alternate" lang="fr" xml:lang="fr" title="Un programme Haskell fonctionnel" type="text/html" hreflang="fr" href="/Scratch/fr/blog/Haskell-OpenGL-Mandelbrot/" /> 
        <link rel="alternate" lang="en" xml:lang="en" title="Haskell Working Program" type="text/html" hreflang="en" href="/Scratch/en/blog/Haskell-OpenGL-Mandelbrot/" /> 
        <script type="text/javascript" src="/Scratch/js/jquery-1.3.1.min.js"></script>
        <script type="text/javascript" src="/Scratch/js/jquery.cookie.js"></script>
        <script type="text/javascript" src="/Scratch/js/index.js"></script>
        <script type="text/javascript" src="/Scratch/js/highlight/highlight.pack.js"></script>                 
        <script type="text/javascript" src="/Scratch/js/article.js"></script>                 
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <!--[if lt IE 9]>
        <script src="http://ie7-js.googlecode.com/svn/version/2.1(beta4)/IE9.js"></script>
        <![endif]-->
        <title>Haskell Working Program</title>
    </head>
    <body lang="en" class="article">
        <script type="text/javascript">// <![CDATA[
            document.write('<div id="blackpage"><img src="/Scratch/img/loading.gif" alt="loading..."/></div>');
            // ]]>
        </script>

        <div id="content">
            <div id="choix"> 
                <div class="return"><a href="#entete">&darr; Menu &darr;</a></div>
                <div id="choixlang"><a href="/Scratch/fr/blog/Haskell-OpenGL-Mandelbrot/" onclick="setLanguage('fr')">en Fran√ßais</a>
                </div>
                <div class="flush"></div>
            </div>
            <div id="titre">
                <h1>
                    Haskell Working Program
                </h1>
                 
                <h2>
                    An OpenGL 3D extension of the Mandelbrot set 
                </h2>
                
            </div>
            <div class="flush"></div>

            

            

            <div class="flush"></div>
            <div id="afterheader">
                <div class="corps">
                    <p><img alt="The plan in image" src="/Scratch/img/blog/Haskell-OpenGL-Mandelbrot/HGL_Plan.png" /></p>


<div class="intro">


<p><span class="sc"><abbr title="Too long; didn't read">tl;dr</abbr>: </span> A progressive real world example.</p>

<blockquote>
  <center><hr style="width:30%;float:left;border-color:#CCCCD0;margin-top:1em" /><span class="sc"><b>Table of Content</b></span><hr style="width:30%;float:right;border-color:#CCCCD0;margin-top:1em" /></center>

<ul id="markdown-toc">
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#first-version">First version</a>    <ul>
      <li><a href="#lets-play-the-song-of-our-people">Let&rsquo;s play the song of our people</a></li>
      <li><a href="#let-us-start">Let us start</a></li>
    </ul>
  </li>
  <li><a href="#only-the-edges">Only the edges</a></li>
  <li><a href="#d-mandelbrot">3D Mandelbrot?</a>    <ul>
      <li><a href="#the-3d-mandelbrot">The 3D Mandelbrot</a></li>
    </ul>
  </li>
  <li><a href="#cleaning-the-code">Cleaning the code</a></li>
  <li><a href="#functional-organization">Functional organization?</a></li>
  <li><a href="#optimization">Optimization</a></li>
</ul>

</blockquote>


</div>


<h2 id="introduction">Introduction</h2>

<p>TODO: write something nice after reading.</p>

<p>Steps: </p>

<ol>
  <li>Mandelbrot set with Haskell OpenGL</li>
  <li>Mandelbrot edges</li>
  <li>3D Mandelbrot because its fun</li>
  <li>Clean the code from full impure and imperative to purer and purer.</li>
  <li>Refactor the code to separate nicely important parts</li>
  <li>Improve efficiency</li>
</ol>

<p>From 1 to 3 it will be <em>dirtier</em> and <em>dirtier</em>.
At 4, we will make some order in this mess!
Hopefuly for the best!</p>

<p>One of the goal of this article is to show some good properties of Haskell.
In particular, how to make some real world application with a pure functional language.</p>

<p>I know drawing a simple mandelbrot set isn&rsquo;t a &ldquo;real world&rdquo; application. 
But the idea is not to show you a real world application which would be hard to follows, but to give you a way to pass from the pure mindset to some real world application.</p>

<p>To this, I will show you how should progress an application.
It is not something easy to show.
This is why, I preferred work with a program that generate some image.</p>

<p>In a real world application, the first constraint would be to work with some framework.
And generally an imperative one.
Also, the imperative nature of OpenGL make it the perfect choice for an example.</p>

<hr />
<p><a href="code/01_Introduction/hglmandel.lhs" class="cut">01_Introduction/<strong>hglmandel.lhs</strong></a></p>

<h2 id="first-version">First version</h2>

<p>We can consider two parts.
The first being mostly some boilerplate<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>.
The second part, contain more interesting stuff.
Even in this part, there are some necessary boilerplate. 
But it is due to the OpenGL library this time.</p>

<h3 id="lets-play-the-song-of-our-people">Let&rsquo;s play the song of our people</h3>

<div class="codehighlight">


<pre><code class="haskell">import Graphics.Rendering.OpenGL
import Graphics.UI.GLUT
import Data.IORef
</code></pre>


</div>

<p>For efficiency reason, I won&rsquo;t use the default Haskell <code>Complex</code> data type.</p>

<div class="codehighlight">


<pre><code class="haskell">newtype Complex = C (Float,Float) deriving (Show,Eq)
</code></pre>


</div>

<div class="codehighlight">


<pre><code class="haskell">instance Num Complex where
    fromInteger n = C (fromIntegral n,0.0)
    C (x,y) * C (z,t) = C (z*x - y*t, y*z + x*t)
    C (x,y) + C (z,t) = C (x+z, y+t)
    abs (C (x,y))     = C (sqrt (x*x + y*y),0.0)
    signum (C (x,y))  = C (signum x , 0.0)
</code></pre>


</div>

<p>We declare some useful functions for manipulating complex numbers:</p>

<div class="codehighlight">


<pre><code class="haskell">complex :: Float -&gt; Float -&gt; Complex
complex x y = C (x,y)

real :: Complex -&gt; Float
real (C (x,y))    = x

im :: Complex -&gt; Float
im   (C (x,y))    = y

magnitude :: Complex -&gt; Float
magnitude = real.abs
</code></pre>


</div>

<h3 id="let-us-start">Let us start</h3>

<p>Well, up until here we didn&rsquo;t made something useful.
Just a lot of boilerplate and default value.
Sorry but it is not completely the end.
We start by giving the main architecture of our program:</p>

<div class="codehighlight">


<pre><code class="haskell">main :: IO ()
main = do
  -- GLUT need to be initialized
  (progname,_) &lt;- getArgsAndInitialize
  -- We will use the double buffered mode (GL constraint)
  initialDisplayMode $= [DoubleBuffered]
  -- We create a window with some title
  createWindow "Mandelbrot Set with Haskell and OpenGL"
  -- Each time we will need to update the display
  -- we will call the function 'display'
  displayCallback $= display
  -- We enter the main loop
  mainLoop
</code></pre>


</div>

<p>The only interesting part is we declared that the function <code>display</code> will be used to render the graphics:</p>

<div class="codehighlight">


<pre><code class="haskell">display = do
  clear [ColorBuffer] -- make the window black
  loadIdentity -- reset any transformation
  preservingMatrix drawMandelbrot
  swapBuffers -- refresh screen
</code></pre>


</div>

<p>Also here, there is only one interesting part, 
the draw will occurs in the function <code>drawMandelbrot</code>.</p>

<p>Now we must speak a bit about how OpenGL works.
We said that OpenGL is imperative by design.
In fact, you must write the list of actions in the right order.
No easy parallel drawing here.
Here is the function which will render something on the screen:</p>

<div class="codehighlight">


<pre><code class="haskell">drawMandelbrot =
  -- We will print Points (not triangles for example) 
  renderPrimitive Points $ do
    mapM_ drawColoredPoint allPoints
  where
      drawColoredPoint (x,y,c) = do
          color c -- set the current color to c
          -- then draw the point at position (x,y,0)
          -- remember we're in 3D
          vertex $ Vertex3 x y 0 
</code></pre>


</div>

<p>The <code>mapM_</code> function is mainly the same as map but inside a monadic context.
More precisely, this can be transformed as a list of actions where the order is important:</p>

<pre><code>drawMandelbrot = 
  renderPrimitive Points $ do
    color color1
    vertex $ Vertex3 x1 y1 0
    ...
    color colorN
    vertex $ Vertex3 xN yN 0
</code></pre>

<p>We also need some kind of global variables. 
In fact, global variable are a proof of some bad design. 
But remember it is our first try:</p>

<div class="codehighlight">


<pre><code class="haskell">width = 320 :: GLfloat
height = 320 :: GLfloat
</code></pre>


</div>

<p>And of course our list of colored points.
In OpenGL the default coordinate are from -1 to 1.</p>

<div class="codehighlight">


<pre><code class="haskell">allPoints :: [(GLfloat,GLfloat,Color3 GLfloat)]
allPoints = [ (x/width,y/height,colorFromValue $ mandel x y) | 
                  x &lt;- [-width..width], 
                  y &lt;- [-height..height]]

</code></pre>


</div>

<p>We need a function which transform an integer value to some color:</p>

<div class="codehighlight">


<pre><code class="haskell">colorFromValue n =
  let 
      t :: Int -&gt; GLfloat
      t i = 0.5 + 0.5*cos( fromIntegral i / 10 )
  in
    Color3 (t n) (t (n+5)) (t (n+10))
</code></pre>


</div>

<p>And now the mandel function. 
Given two coordinates in pixels, it returns some integer value:</p>

<div class="codehighlight">


<pre><code class="haskell">mandel x y = 
  let r = 2.0 * x / width
      i = 2.0 * y / height
  in
      f (complex r i) 0 64
</code></pre>


</div>

<p>It uses the main mandelbrot function for each complex \(c\).
The mandelbrot set is the set of complex number c such that the following sequence does not escape to infinity.</p>

<p>Let us define \(f_c: \mathbb{C} \to \mathbb{C}\)</p>

<script type="math/tex; mode=display"> f_c(z) = z^2 + c </script>

<p>The sequence is: </p>

<script type="math/tex; mode=display"> 0 \rightarrow f_c(0) \rightarrow f_c(f_c(0)) \rightarrow \cdots \rightarrow f^n_c(0) \rightarrow \cdots </script>

<p>Of course, instead of trying to test the real limit, we just make a test after a finite number of occurrences.</p>

<div class="codehighlight">


<pre><code class="haskell">f :: Complex -&gt; Complex -&gt; Int -&gt; Int
f c z 0 = 0
f c z n = if (magnitude z &gt; 2 ) 
          then n
          else f c ((z*z)+c) (n-1)
</code></pre>


</div>

<p>Well, if you download this lhs file, compile it and run it this is the result:</p>

<p><img alt="The mandelbrot set version 1" src="/Scratch/img/blog/Haskell-OpenGL-Mandelbrot/hglmandel_v01.png" /></p>

<p>A first very interesting property of this program is that the computation for all the points is done only once.
The proof is that it might be a bit long before a first image appears, but if you resize the window, it updates instantaneously.
This property is a direct consequence of purity.
If you look closely, you see that <code>allPoints</code> is a pure list.
Therefore, calling <code>allPoints</code> will always render the same result.
While Haskell doesn&rsquo;t garbage collect <code>allPoints</code> the result is reused for free.
We didn&rsquo;t specified this value should be saved for later use. 
It is saved for us.</p>

<p>See what occurs if we make the window bigger:</p>

<p><img alt="The mandelbrot too wide, black lines and columns" src="/Scratch/img/blog/Haskell-OpenGL-Mandelbrot/hglmandel_v01_too_wide.png" /></p>

<p>Yep, we see some black lines.
Why? Simply because we drawn less point than there is on the surface.
We can repair this by drawing little squares instead of just points.
But, instead we will do something a bit different and unusual.</p>

<p><a href="code/01_Introduction/hglmandel.lhs" class="cut">01_Introduction/<strong>hglmandel.lhs</strong> </a></p>

<hr />
<p><a href="code/02_Edges/HGLMandelEdge.lhs" class="cut">02_Edges/<strong>HGLMandelEdge.lhs</strong></a></p>

<h2 id="only-the-edges">Only the edges</h2>

<div style="display:none">

<div class="codehighlight">


<pre><code class="haskell">import Graphics.Rendering.OpenGL
import Graphics.UI.GLUT
import Data.IORef
newtype Complex = C (Float,Float) deriving (Show,Eq)
instance Num Complex where
    fromInteger n = C (fromIntegral n,0.0)
    C (x,y) * C (z,t) = C (z*x - y*t, y*z + x*t)
    C (x,y) + C (z,t) = C (x+z, y+t)
    abs (C (x,y))     = C (sqrt (x*x + y*y),0.0)
    signum (C (x,y))  = C (signum x , 0.0)
complex :: Float -&gt; Float -&gt; Complex
complex x y = C (x,y)

real :: Complex -&gt; Float
real (C (x,y))    = x

im :: Complex -&gt; Float
im   (C (x,y))    = y

magnitude :: Complex -&gt; Float
magnitude = real.abs
main :: IO ()
main = do
  -- GLUT need to be initialized
  (progname,_) &lt;- getArgsAndInitialize
  -- We will use the double buffered mode (GL constraint)
  initialDisplayMode $= [DoubleBuffered]
  -- We create a window with some title
  createWindow "Mandelbrot Set with Haskell and OpenGL"
  -- Each time we will need to update the display
  -- we will call the function 'display'
  displayCallback $= display
  -- We enter the main loop
  mainLoop
display = do
   -- set the background color (dark solarized theme)
  clearColor $= Color4 0 0.1686 0.2117 1
  clear [ColorBuffer] -- make the window black
  loadIdentity -- reset any transformation
  preservingMatrix drawMandelbrot
  swapBuffers -- refresh screen

width = 320 :: GLfloat
height = 320 :: GLfloat
</code></pre>


</div>

</div>

<p>This time, instead of drawing all points, I&rsquo;ll simply want to draw the edges of the Mandelbrot set.
We change slightly the drawMandelbrot function.
We replace the <code>Points</code> by <code>LineLoop</code></p>

<div class="codehighlight">


<pre><code class="haskell">drawMandelbrot =
  -- We will print Points (not triangles for example) 
  renderPrimitive LineLoop $ do
    mapM_ drawColoredPoint allPoints
  where
      drawColoredPoint (x,y,c) = do
          color c -- set the current color to c
          -- then draw the point at position (x,y,0)
          -- remember we're in 3D
          vertex $ Vertex3 x y 0 
</code></pre>


</div>

<p>And now, we should change our list of points.
Instead of drawing every point of the visible surface, 
we will choose only point on the surface.</p>

<div class="codehighlight">


<pre><code class="haskell">allPoints = positivePoints ++ 
      map (\(x,y,c) -&gt; (x,-y,c)) (reverse positivePoints)
</code></pre>


</div>

<p>We only need to compute the positive point.
The mandelbrot set is symetric on the abscisse axis.</p>

<div class="codehighlight">


<pre><code class="haskell">positivePoints :: [(GLfloat,GLfloat,Color3 GLfloat)]
positivePoints = do
              x &lt;- [-width..width]
              let y = findMaxOrdFor (mandel x) 0 height 10 -- log height
              if y &lt; 1 -- We don't draw point in the absciss
                 then []
                 else return (x/width,y/height,colorFromValue $ mandel x y)
</code></pre>


</div>

<p>This function is interresting. 
For those not used to the list monad here is a natural language version of this function:</p>

<pre><code>positivePoints =
    for all x in the range [-width..width]
    let y be smallest number s.t. mandel x y &gt; 0
    if y is on 0 then don't return a point
    else return the value corresonding to (x,y,color for (x+iy))
</code></pre>

<p>In fact using the list monad you write like if you consider only one element at a time and the computation is done non deterministically.
To find the smallest number such that mandel x y &gt; 0 we create a simple dichotomic search:</p>

<div class="codehighlight">


<pre><code class="haskell">findMaxOrdFor func minval maxval 0 = (minval+maxval)/2
findMaxOrdFor func minval maxval n = 
  if (func medpoint) /= 0 
       then findMaxOrdFor func minval medpoint (n-1)
       else findMaxOrdFor func medpoint maxval (n-1)
  where medpoint = (minval+maxval)/2
</code></pre>


</div>

<p>No rocket science here.
I know, due to the fact the mandelbrot set is not convex this approach does some errors. But the approximation will be good enough.
See the result now:</p>

<p><img alt="The edges of the mandelbrot set" src="/Scratch/img/blog/Haskell-OpenGL-Mandelbrot/HGLMandelEdges.png" /></p>

<div style="display:none">

<div class="codehighlight">


<pre><code class="haskell">colorFromValue n =
  let 
      t :: Int -&gt; GLfloat
      t i = 0.5 + 0.5*cos( fromIntegral i / 10 )
  in
    Color3 (t n) (t (n+5)) (t (n+10))
</code></pre>


</div>

<div class="codehighlight">


<pre><code class="haskell">mandel x y = 
  let r = 2.0 * x / width
      i = 2.0 * y / height
  in
      f (complex r i) 0 64
</code></pre>


</div>

<div class="codehighlight">


<pre><code class="haskell">f :: Complex -&gt; Complex -&gt; Int -&gt; Int
f c z 0 = 0
f c z n = if (magnitude z &gt; 2 ) 
          then n
          else f c ((z*z)+c) (n-1)
</code></pre>


</div>

</div>

<p><a href="code/02_Edges/HGLMandelEdge.lhs" class="cut">02_Edges/<strong>HGLMandelEdge.lhs</strong> </a></p>

<hr />
<p><a href="code/03_Mandelbulb/Mandelbulb.lhs" class="cut">03_Mandelbulb/<strong>Mandelbulb.lhs</strong></a></p>

<h2 id="d-mandelbrot">3D Mandelbrot?</h2>

<p>Why only draw the edge? 
It is clearly not as nice as drawing the complete surface.
Yeah, I know, but, as we use OpenGL, why not show something in 3D.</p>

<p>But, complex number are only in 2D and there is no 3D equivalent to complex.
In fact, the only extension known are quaternions, 4D.
As I know almost nothing about quaternions, I will use some extended complex.
I am pretty sure this construction is not useful for numbers.
But it will be enough for us to create something nice.</p>

<p>As there is a lot of code, I&rsquo;ll give a high level view to what occurs:</p>

<blockquote>
  <ul>
    <li>
      <p>OpenGL Boilerplate</p>

      <ul>
        <li>set some IORef for states  </li>
        <li>
          <p>Drawing: </p>

          <ul>
            <li>set doubleBuffer, handle depth, window size&hellip;</li>
            <li>Use state to apply some transformations</li>
          </ul>
        </li>
        <li>Keyboard: hitting some key change the state of IORef</li>
      </ul>
    </li>
    <li>
      <p>Generate 3D Object</p>

      <pre><code>allPoints :: [ColoredPoint]  
allPoints =
    for all (x,y), -width&lt;x&lt;width, 0&lt;y&lt;height
    Let z be the minimal depth such that
        mandel x y z &gt; 0
    add the points 
           (x, y, z,color) 
           (x,-y, z,color) 
           (x, y,-z,color) 
           (x,-y,-z,color) 
        + neighbors to make triangles
</code></pre>
    </li>
  </ul>
</blockquote>

<div style="display:none">

<div class="codehighlight">


<pre><code class="haskell">import Graphics.Rendering.OpenGL
import Graphics.UI.GLUT
import Data.IORef
type ColoredPoint = (GLfloat,GLfloat,GLfloat,Color3 GLfloat)
</code></pre>


</div>

</div>

<p>We declare a new type <code>ExtComplex</code> (for exttended complex). 
An extension of complex numbers:</p>

<div class="codehighlight">


<pre><code class="haskell">data ExtComplex = C (GLfloat,GLfloat,GLfloat) 
                  deriving (Show,Eq)
instance Num ExtComplex where
    -- The shape of the 3D mandelbrot 
    -- will depend on this formula
    C (x,y,z) * C (x',y',z') = C (x*x' - y*y' - z*z', 
                                  x*y' + y*x' + z*z', 
                                  x*z' + z*x' )
    -- The rest is straightforward
    fromInteger n = C (fromIntegral n, 0, 0)
    C (x,y,z) + C (x',y',z') = C (x+x', y+y', z+z')
    abs (C (x,y,z))     = C (sqrt (x*x + y*y + z*z), 0, 0)
    signum (C (x,y,z))  = C (signum x, 0, 0)
</code></pre>


</div>

<p>The most important part is the new multiplication instance.
Modifying this formula will change radically the shape of this somehow 3D mandelbrot.</p>

<div style="display:none">

<div class="codehighlight">


<pre><code class="haskell">extcomplex :: GLfloat -&gt; GLfloat -&gt; GLfloat -&gt; ExtComplex
extcomplex x y z = C (x,y,z)

real :: ExtComplex -&gt; GLfloat
real (C (x,y,z))    = x

im :: ExtComplex -&gt; GLfloat
im   (C (x,y,z))    = y

strange :: ExtComplex -&gt; GLfloat
strange (C (x,y,z)) = z

magnitude :: ExtComplex -&gt; GLfloat
magnitude = real.abs
</code></pre>


</div>

</div>

<p>As we will use some 3D, we add some new directive in the boilerplate.
But mainly, we simply state that will use some depth buffer.
And also we will listen the keyboard.</p>

<div class="codehighlight">


<pre><code class="haskell">main :: IO ()
main = do
  -- GLUT need to be initialized
  (progname,_) &lt;- getArgsAndInitialize
  -- We will use the double buffered mode (GL constraint)
  -- We also Add the DepthBuffer (for 3D)
  initialDisplayMode $= 
      [WithDepthBuffer,DoubleBuffered,RGBMode]
  -- We create a window with some title
  createWindow "3D HOpengGL Mandelbrot"
  -- We add some directives
  depthFunc  $= Just Less
  -- matrixMode $= Projection
  windowSize $= Size 500 500
  -- Some state variables (I know it feels BAD)
  angle   &lt;- newIORef ((35,0)::(GLfloat,GLfloat))
  zoom    &lt;- newIORef (2::GLfloat)
  campos  &lt;- newIORef ((0.7,0)::(GLfloat,GLfloat))
  -- Action to call when waiting
  idleCallback $= Just idle
  -- We will use the keyboard
  keyboardMouseCallback $= 
          Just (keyboardMouse angle zoom campos)
  -- Each time we will need to update the display
  -- we will call the function 'display'
  -- But this time, we add some parameters
  displayCallback $= display angle zoom campos
  -- We enter the main loop
  mainLoop
</code></pre>


</div>

<p>The <code>idle</code> function necessary for animation.</p>

<div class="codehighlight">


<pre><code class="haskell">idle = postRedisplay Nothing
</code></pre>


</div>

<p>We introduce some helper function to manipulate
standard <code>IORef</code>.</p>

<div class="codehighlight">


<pre><code class="haskell">modVar v f = do
  v' &lt;- get v
  v $= (f v')
mapFst f (x,y) = (f x,  y)
mapSnd f (x,y) = (  x,f y)
</code></pre>


</div>

<p>And we use them to code the function handling keyboard.
We will use the keys <code>hjkl</code> to rotate, 
<code>oi</code> to zoom and <code>sedf</code> to move.
Also, hitting space will reset the view.</p>

<div class="codehighlight">


<pre><code class="haskell">keyboardMouse angle zoom pos key state modifiers position =
  kact angle zoom pos key state
  where 
    -- reset view when hitting space
    kact a z p (Char ' ') Down = do
          a $= (0,0)
          z $= 1
          p $= (0,0)
    -- use of hjkl to rotate
    kact a _ _ (Char 'h') Down = modVar a (mapFst (+0.5))
    kact a _ _ (Char 'l') Down = modVar a (mapFst (+(-0.5)))
    kact a _ _ (Char 'j') Down = modVar a (mapSnd (+0.5))
    kact a _ _ (Char 'k') Down = modVar a (mapSnd (+(-0.5)))
    -- use o and i to zoom
    kact _ s _ (Char 'o') Down = modVar s (*1.1)
    kact _ s _ (Char 'i') Down = modVar s (*0.9)
    -- use sdfe to move the camera
    kact _ _ p (Char 's') Down = modVar p (mapFst (+0.1))
    kact _ _ p (Char 'f') Down = modVar p (mapFst (+(-0.1)))
    kact _ _ p (Char 'd') Down = modVar p (mapSnd (+0.1))
    kact _ _ p (Char 'e') Down = modVar p (mapSnd (+(-0.1)))
    -- any other keys does nothing
    kact _ _ _ _ _ = return ()
</code></pre>


</div>

<p>Now, we will show the object using the display function.
Note, this time, display take some parameters.
Mainly, this function if full of boilerplate:</p>

<div class="codehighlight">


<pre><code class="haskell">display angle zoom position = do
   -- set the background color (dark solarized theme)
  clearColor $= Color4 0 0.1686 0.2117 1
  clear [ColorBuffer,DepthBuffer]
  -- Transformation to change the view
  loadIdentity -- reset any transformation
  -- tranlate
  (x,y) &lt;- get position
  translate $ Vector3 x y 0 
  -- zoom
  z &lt;- get zoom
  scale z z z
  -- rotate
  (xangle,yangle) &lt;- get angle
  rotate xangle $ Vector3 1.0 0.0 (0.0::GLfloat)
  rotate yangle $ Vector3 0.0 1.0 (0.0::GLfloat)
  -- Now that all transformation were made
  -- We create the object(s)
  preservingMatrix drawMandelbrot
  swapBuffers -- refresh screen
</code></pre>


</div>

<p>Not much to say about this function.
Mainly there are two parts: apply some transformations, draw the object.</p>

<h3 id="the-3d-mandelbrot">The 3D Mandelbrot</h3>

<p>Now, that we talked about the OpenGL part, let&rsquo;s talk about how we 
generate the 3D points and colors.
First, we will set the number of detatils to 180 pixels in the three dimensions.</p>

<div class="codehighlight">


<pre><code class="haskell">nbDetails = 200 :: GLfloat
width  = nbDetails
height = nbDetails
deep   = nbDetails
</code></pre>


</div>

<p>This time, instead of just drawing some line or some group of points,
we will show triangles.
The idea is that we should provide points three by three.</p>

<div class="codehighlight">


<pre><code class="haskell">drawMandelbrot = do
  -- We will print Points (not triangles for example) 
  renderPrimitive Triangles $ do
    mapM_ drawColoredPoint allPoints
  where
      drawColoredPoint (x,y,z,c) = do
          color c
          vertex $ Vertex3 x y z
</code></pre>


</div>

<p>Now instead of providing only one point at a time, we will provide six ordered points. 
These points will be used to draw two triangles.</p>

<p><img alt="Explain triangles" src="/Scratch/img/blog/Haskell-OpenGL-Mandelbrot/triangles.png" /></p>

<p>Note in 3D the depth of the point is generally different.
The next function is a bit long. 
An approximative English version is:</p>

<pre><code>forall x from -width to width
  forall y from -height to height
    forall the neighbors of (x,y)
      let z be the smalled depth such that (mandel x y z)&gt;0
      let c be the color given by mandel x y z 
      add the point corresponding to (x,y,z,c)
</code></pre>

<p>Also, I added a test to hide points too far from the border.
In fact, this function show points close to the surface of the modified mandelbrot set. But not the mandelbrot set itself.</p>

<pre><code class="haskell">depthPoints :: [ColoredPoint]
depthPoints = do
  x &lt;- [-width..width]
  y &lt;- [-height..height]
  let 
      depthOf x' y' = findMaxOrdFor (mandel x' y') 0 deep 7
      z1 = depthOf    x     y
      z2 = depthOf (x+1)    y
      z3 = depthOf (x+1) (y+1)
      z4 = depthOf    x  (y+1)
      c1 = mandel    x     y  (z1+1)
      c2 = mandel (x+1)    y  (z2+1)
      c3 = mandel (x+1) (y+1) (z3+1)
      c4 = mandel    x  (y+1) (z4+1)
      p1 = (   x /width,   y /height, z1/deep,colorFromValue c1)
      p2 = ((x+1)/width,   y /height, z2/deep,colorFromValue c2)
      p3 = ((x+1)/width,(y+1)/height, z3/deep,colorFromValue c3)
      p4 = (   x /width,(y+1)/height, z4/deep,colorFromValue c4)
  if (and $ map (&gt;=57) [c1,c2,c3,c4])
  then []
  else [p1,p2,p3,p1,p3,p4]
</code></pre>

<p>If you look at the function above, you see a lot of common patterns.
Haskell is very efficient to make this better.
Here is a somehow less readable but more generic refactored function:</p>

<div class="codehighlight">


<pre><code class="haskell">depthPoints :: [ColoredPoint]
depthPoints = do
  x &lt;- [-width..width]
  y &lt;- [0..height]
  let 
    neighbors = [(x,y),(x+1,y),(x+1,y+1),(x,y+1)]
    depthOf (u,v) = findMaxOrdFor (mandel u v) 0 deep 7
    -- zs are 3D points with found depth
    zs = map (\(u,v) -&gt; (u,v,depthOf (u,v))) neighbors
    -- ts are 3D pixels + mandel value
    ts = map (\(u,v,w) -&gt; (u,v,w,mandel u v (w+1))) zs
    -- ps are 3D opengl points + color value
    ps = map (\(u,v,w,c') -&gt; 
        (u/width,v/height,w/deep,colorFromValue c')) ts
  -- If the point diverged too fast, don't display it
  if (and $ map (\(_,_,_,c) -&gt; c&gt;=57) ts)
  then []
  -- Draw two triangles
  else [ps!!0,ps!!1,ps!!2,ps!!0,ps!!2,ps!!3]
</code></pre>


</div>

<p>If you prefer the first version, then just imagine how hard it will be to change the enumeration of the point from (x,y) to (x,z) for example.</p>

<p>Also, we didn&rsquo;t searched for negative values. 
For simplicity, I mirror these values. 
I haven&rsquo;t even tested if this modified mandelbrot is symetric relatively to the plan {(x,y,z)|z=0}.</p>

<div class="codehighlight">


<pre><code class="haskell">allPoints :: [ColoredPoint]
allPoints = planPoints ++ map inverseDepth  planPoints
  where 
      planPoints = depthPoints ++ map inverseHeight depthPoints
      inverseHeight (x,y,z,c) = (x,-y,z,c)
      inverseDepth (x,y,z,c) = (x,y,-z+1/deep,c)
</code></pre>


</div>

<p>I cheat by making these symmetry.
But it is faster and render a nice form.
For this tutorial it will be good enough.
Also, the dichotomic method I use is mostly right but false for some cases.</p>

<p>The rest of the program is very close to the preceeding one.</p>

<div style="display:none">

<div class="codehighlight">


<pre><code class="haskell">findMaxOrdFor func minval maxval 0 = (minval+maxval)/2
findMaxOrdFor func minval maxval n = 
  if (func medpoint) /= 0 
       then findMaxOrdFor func minval medpoint (n-1)
       else findMaxOrdFor func medpoint maxval (n-1)
  where medpoint = (minval+maxval)/2
</code></pre>


</div>

I made the color slightly brighter

<div class="codehighlight">


<pre><code class="haskell">colorFromValue n =
  let 
      t :: Int -&gt; GLfloat
      t i = 0.7 + 0.3*cos( fromIntegral i / 10 )
  in
    Color3 (t n) (t (n+5)) (t (n+10))
</code></pre>


</div>

We only changed from `Complex` to `ExtComplex` of the main `f` function.

<div class="codehighlight">


<pre><code class="haskell">f :: ExtComplex -&gt; ExtComplex -&gt; Int -&gt; Int
f c z 0 = 0
f c z n = if (magnitude z &gt; 2 ) 
          then n
          else f c ((z*z)+c) (n-1)
</code></pre>


</div>

</div>

<p>We simply add a new dimenstion to the mandel function. Also we simply need to change the type signature of the function <code>f</code> from <code>Complex</code> to <code>ExtComplex</code>.</p>

<div class="codehighlight">


<pre><code class="haskell">mandel x y z = 
  let r = 2.0 * x / width
      i = 2.0 * y / height
      s = 2.0 * z / deep
  in
      f (extcomplex r i s) 0 64
</code></pre>


</div>

<p>And here is the result (if you use 500 for <code>nbDetails</code>):</p>

<p><img alt="A 3D mandelbrot like" src="/Scratch/img/blog/Haskell-OpenGL-Mandelbrot/mandelbrot_3D.png" /></p>

<p>This image is quite nice.</p>

<p><a href="code/03_Mandelbulb/Mandelbulb.lhs" class="cut">03_Mandelbulb/<strong>Mandelbulb.lhs</strong> </a></p>

<hr />
<p><a href="code/04_Mandelbulb/Mandelbulb.lhs" class="cut">04_Mandelbulb/<strong>Mandelbulb.lhs</strong></a></p>

<h2 id="cleaning-the-code">Cleaning the code</h2>

<p>The first thing to do is to separate the GLUT/OpenGL 
part from the computation of the shape.
Here is the cleaned version of the preceeding section.
Most boilerplate was put in external files.</p>

<ul>
  <li><a href="code/04_Mandelbulb/YBoiler.hs"><code>YBoiler.hs</code></a>, the 3D rendering</li>
  <li><a href="code/04_Mandelbulb/Mandel.hs"><code>Mandel</code></a>, the mandel function</li>
  <li><a href="code/04_Mandelbulb/ExtComplex.hs"><code>ExtComplex</code></a>, the extended complexes</li>
</ul>

<div class="codehighlight">


<pre><code class="haskell">import YBoiler -- Most the OpenGL Boilerplate
import Mandel -- The 3D Mandelbrot maths
</code></pre>


</div>

<p>The <code>yMainLoop</code> takes two arguments:
the title of the window 
and a function from time to triangles</p>

<div class="codehighlight">


<pre><code class="haskell">main :: IO ()
main = yMainLoop "3D Mandelbrot" (\_ -&gt; allPoints)
</code></pre>


</div>

<p>We set some global constant (this is generally bad).</p>

<div class="codehighlight">


<pre><code class="haskell">nbDetails = 200 :: GLfloat
width  = nbDetails
height = nbDetails
deep   = nbDetails
</code></pre>


</div>

<p>We then generate colored points from our function.
This is similar to the preceding section.</p>

<div class="codehighlight">


<pre><code class="haskell">allPoints :: [ColoredPoint]
allPoints = planPoints ++ map inverseDepth  planPoints
  where 
      planPoints = depthPoints ++ map inverseHeight depthPoints
      inverseHeight (x,y,z,c) = (x,-y,z,c)
      inverseDepth (x,y,z,c) = (x,y,-z+1/deep,c)
</code></pre>


</div>

<div class="codehighlight">


<pre><code class="haskell">depthPoints :: [ColoredPoint]
depthPoints = do
  x &lt;- [-width..width]
  y &lt;- [0..height]
  let 
    neighbors = [(x,y),(x+1,y),(x+1,y+1),(x,y+1)]
    depthOf (u,v) = findMaxOrdFor (ymandel u v) 0 deep 7
    -- zs are 3D points with found depth
    zs = map (\(u,v) -&gt; (u,v,depthOf (u,v))) neighbors
    -- ts are 3D pixels + mandel value
    ts = map (\(u,v,w) -&gt; (u,v,w,ymandel u v (w+1))) zs
    -- ps are 3D opengl points + color value
    ps = map (\(u,v,w,c') -&gt; 
        (u/width,v/height,w/deep,colorFromValue c')) ts
  -- If the point diverged too fast, don't display it
  if (and $ map (\(_,_,_,c) -&gt; c&gt;=57) ts)
  then []
  -- Draw two triangles
  else [ps!!0,ps!!1,ps!!2,ps!!0,ps!!2,ps!!3]

findMaxOrdFor func minval maxval 0 = (minval+maxval)/2
findMaxOrdFor func minval maxval n = 
  if (func medpoint) /= 0 
       then findMaxOrdFor func minval medpoint (n-1)
       else findMaxOrdFor func medpoint maxval (n-1)
  where medpoint = (minval+maxval)/2

colorFromValue n =
  let 
      t :: Int -&gt; GLfloat
      t i = 0.7 + 0.3*cos( fromIntegral i / 10 )
  in
    ((t n),(t (n+5)),(t (n+10)))

ymandel x y z = mandel (2*x/width) (2*y/height) (2*z/deep) 64
</code></pre>


</div>

<p>This code is cleaner but many things doesn&rsquo;t feel right.
First, all the user interaction code is outside our main file.
I feel it is okay to hide the detail for the rendering.
But I would have preferred to control the user actions.</p>

<p>On the other hand, we continue to handle a lot rendering details.
For example, we provide ordered vertices.
I feel, this should be externalized.</p>

<p>I would have preferred to make things a bit more general.</p>

<p><a href="code/04_Mandelbulb/Mandelbulb.lhs" class="cut">04_Mandelbulb/<strong>Mandelbulb.lhs</strong> </a></p>

<hr />
<p><a href="code/05_Mandelbulb/Mandelbulb.lhs" class="cut">05_Mandelbulb/<strong>Mandelbulb.lhs</strong></a></p>

<h2 id="functional-organization">Functional organization?</h2>

<p>Some points:</p>

<ol>
  <li>OpenGL and GLUT are linked to the C library.
In particular the <code>mainLoop</code> function is a direct link to the C library (FFI).
This function if so far from the pure spirit of functional languages.
Could we make this better?
We will have two choices, or create our own <code>mainLoop</code> function to make it more functional.
Or deal with the imperative nature of the GLUT <code>mainLoop</code> function.
As a goal of this article is to understand how to deal with existing library and particularly the one coming from imperative language we will continue to use the <code>mainLoop</code> function.</li>
  <li>Or main problem come from user interaction.
If you ask the Internet, about how to deal with user interaction with a functional paradigm, the main answer is to use <em>functional reactive programming</em> (FRP).
I read very few about FRP, and I might be completely wrong when I say that it is about creating a DSL where atoms are time functions.
While I&rsquo;m writing these lines, I don&rsquo;t know if I&rsquo;ll do something looking close to that.
For now I&rsquo;ll simply try to resolve the first problem.</li>
</ol>

<p>Then here is how I imagine things should go.
First, what the main loop should look like:</p>

<pre><code class="haskell">functionalMainLoop =
    Read user inputs and provide a list of actions
    Apply all actions to the World
    Display one frame 
    repetere aeternum
</code></pre>

<p>Clearly, ideally we should provide only three parameters to this main loop function:</p>

<ul>
  <li>an initial World state</li>
  <li>a mapping between the user interaction and function which modify the world</li>
  <li>a function taking two parameters: time and world state and render a new world without user interaction.</li>
</ul>

<p>Here is a real working code, I&rsquo;ve hidden most display functions.
The YGL, is a kind of framework to display 3D functions.
But it can easily be extended to many kind of representation.</p>

<div class="codehighlight">


<pre><code class="haskell">import YGL -- Most the OpenGL Boilerplate
import Mandel -- The 3D Mandelbrot maths
</code></pre>


</div>

<p>We first set the mapping between user input and actions.
The type of each couple should be of the form
<code>(user input, f)</code> where (in a first time) <code>f:World -&gt; World</code>.
It means, the user input will transform the world state.</p>

<div class="codehighlight">


<pre><code class="haskell">-- Centralize all user input interaction
inputActionMap :: InputMap World
inputActionMap = inputMapFromList [
     (Press 'k' , rotate xdir 5)
    ,(Press 'i' , rotate xdir (-5))
    ,(Press 'j' , rotate ydir 5)
    ,(Press 'l' , rotate ydir (-5))
    ,(Press 'o' , rotate zdir 5)
    ,(Press 'u' , rotate zdir (-5))
    ,(Press 'f' , translate xdir 0.1)
    ,(Press 's' , translate xdir (-0.1))
    ,(Press 'e' , translate ydir 0.1)
    ,(Press 'd' , translate ydir (-0.1))
    ,(Press 'z' , translate zdir 0.1)
    ,(Press 'r' , translate zdir (-0.1))
    ,(Press '+' , zoom 1.1)
    ,(Press '-' , zoom (1/1.1))
    ,(Press 'h' , resize 1.2)
    ,(Press 'g' , resize (1/1.2))
    ]
</code></pre>


</div>

<p>And of course a type design the World State. 
The important part is that it is our World State type.
We could have used any kind of data type.</p>

<div class="codehighlight">


<pre><code class="haskell">-- I prefer to set my own name for these types
data World = World {
      angle       :: Point3D
    , scale       :: Scalar
    , position    :: Point3D
    , shape       :: Scalar -&gt; Function3D
    , box         :: Box3D
    , told        :: Time -- last frame time
    } 
</code></pre>


</div>

<p>The important part to glue our own type to the framework
is to make our type an instance of the type class <code>DisplayableWorld</code>.
We simply have to provide the definition of some functions.</p>

<div class="codehighlight">


<pre><code class="haskell">instance DisplayableWorld World where
  winTitle _ = "The YGL Mandelbulb"
  camera w = Camera {
        camPos = position w, 
        camDir = angle w,
        camZoom = scale w }
  objects w = [XYFunc ((shape  w) res) defbox]
              where
                  res = resolution $ box w
                  defbox = box w
</code></pre>


</div>

<p>The <code>camera</code> function will retrieve an object of type <code>Camera</code> which contains
most necessary information to set our camera.
The <code>objects</code> function will returns a list of objects. 
Their type is <code>YObject</code>. Note the generation of triangles is no more in this file.
Until here we only used declarative pattern.</p>

<p>We also need to set all our transformation functions.
These function are used to update the world state.</p>

<div class="codehighlight">


<pre><code class="haskell">xdir :: Point3D
xdir = makePoint3D (1,0,0)
ydir :: Point3D
ydir = makePoint3D (0,1,0)
zdir :: Point3D
zdir = makePoint3D (0,0,1)
</code></pre>


</div>

<p>Note <code>(-*&lt;)</code> is scalar product.
Also note we could add Point3D as numbers. </p>

<div class="codehighlight">


<pre><code class="haskell">rotate :: Point3D -&gt; Scalar -&gt; World -&gt; World
rotate dir angleValue world = 
  world {
     angle = (angle world) + (angleValue -*&lt; dir) }

translate :: Point3D -&gt; Scalar -&gt; World -&gt; World
translate dir len world = 
  world {
    position = (position world) + (len -*&lt; dir) }

zoom :: Scalar -&gt; World -&gt; World
zoom z world = world {
    scale = z * scale world }

resize :: Scalar -&gt; World -&gt; World
resize r world = world {
    box = (box world) {
     resolution = sqrt ((resolution (box world))**2 * r) }}
</code></pre>


</div>

<p>The resize is used to generate the 3D function.
As I wanted the time spent to generate a more detailed view 
to grow linearly I use this not so straightforward formula.</p>

<p>The <code>yMainLoop</code> takes three arguments.</p>

<ul>
  <li>A map between user Input and world transformation</li>
  <li>A timed world transformation</li>
  <li>An initial world state</li>
</ul>

<div class="codehighlight">


<pre><code class="haskell">main :: IO ()
main = yMainLoop inputActionMap idleAction initialWorld
</code></pre>


</div>

<p>Here is our initial world state.</p>

<div class="codehighlight">


<pre><code class="haskell">-- We initialize the world state
-- then angle, position and zoom of the camera
-- And the shape function
initialWorld :: World
initialWorld = World {
   angle = makePoint3D (-30,-30,0)
 , position = makePoint3D (0,0,0)
 , scale = 0.8
 , shape = shapeFunc 
 , box = Box3D { minPoint = makePoint3D (-2,-2,-2)
               , maxPoint =  makePoint3D (2,2,2)
               , resolution =  0.16 }
 , told = 0
 }
</code></pre>


</div>

<p>We will define <code>shapeFunc</code> later.
Here is the function which transform the world even without user action.
Mainly it makes some rotation.</p>

<div class="codehighlight">


<pre><code class="haskell">idleAction :: Time -&gt; World -&gt; World
idleAction tnew world = world {
    angle = (angle world) + (delta -*&lt; zdir)
  , told = tnew
  }
  where 
      anglePerSec = 5.0
      delta = anglePerSec * elapsed / 1000.0
      elapsed = fromIntegral (tnew - (told world))
</code></pre>


</div>

<p>Now the function which will generate points in 3D.
The first parameter (<code>res</code>) is the resolution of the vertex generation.
More precisely, <code>res</code> is distance between two points on one direction.
We need it to &ldquo;close&rdquo; our shape.</p>

<p>The type <code>Function3D</code> is <code>Point -&gt; Point -&gt; Maybe Point</code>.
Because we consider partial functions
(for some <code>(x,y)</code> our function can be undefined).</p>

<div class="codehighlight">


<pre><code class="haskell">shapeFunc :: Scalar -&gt; Function3D
shapeFunc res x y = 
  let 
      z = findMaxOrdFor (ymandel x y) 0 1 20
  in
  if and [ findMaxOrdFor (ymandel (x+xeps) (y+yeps)) 0 1 20 &lt; 0.000001 |
              val &lt;- [res], xeps &lt;- [-val,val], yeps&lt;-[-val,val]]
      then Nothing 
      else Just (z,colorFromValue ((ymandel x y z) * 64))
</code></pre>


</div>

<p>With the color function.</p>

<div class="codehighlight">


<pre><code class="haskell">colorFromValue :: Point -&gt; Color
colorFromValue n =
  let 
      t :: Point -&gt; Scalar
      t i = 0.7 + 0.3*cos( i / 10 )
  in
    makeColor (t n) (t (n+5)) (t (n+10))
</code></pre>


</div>

<p>The rest is similar to the preceding sections.</p>

<div class="codehighlight">


<pre><code class="haskell">findMaxOrdFor :: (Fractional a,Num a,Num b,Eq b) =&gt; 
                 (a -&gt; b) -&gt; a -&gt; a -&gt; Int -&gt; a
findMaxOrdFor _ minval maxval 0 = (minval+maxval)/2
findMaxOrdFor func minval maxval n = 
  if func medpoint /= 0 
       then findMaxOrdFor func minval medpoint (n-1)
       else findMaxOrdFor func medpoint maxval (n-1)
  where medpoint = (minval+maxval)/2

ymandel :: Point -&gt; Point -&gt; Point -&gt; Point
ymandel x y z = fromIntegral (mandel x y z 64) / 64
</code></pre>


</div>

<p>I won&rsquo;t put how the magic occurs directly here.
But all the magic occurs in the file <code>YGL.hs</code>.
This file is commented a lot.</p>

<ul>
  <li><a href="code/05_Mandelbulb/YGL.hs"><code>YGL.hs</code></a>, the 3D rendering framework</li>
  <li><a href="code/05_Mandelbulb/Mandel.hs"><code>Mandel</code></a>, the mandel function</li>
  <li><a href="code/05_Mandelbulb/ExtComplex.hs"><code>ExtComplex</code></a>, the extended complexes</li>
</ul>

<p><a href="code/05_Mandelbulb/Mandelbulb.lhs" class="cut">05_Mandelbulb/<strong>Mandelbulb.lhs</strong> </a></p>

<hr />
<p><a href="code/06_Mandelbulb/Mandelbulb.lhs" class="cut">06_Mandelbulb/<strong>Mandelbulb.lhs</strong></a></p>

<h2 id="optimization">Optimization</h2>

<p>All feel good from the architecture point of vue.
More precisely, the separation between rendering and world behavior is clear.
But this is extremely slow now.
Because we compute the mandelbulb for each frame now.</p>

<p>Before we had</p>

<p>Constant Function &rarr; Constant List of Triangles &rarr; Display</p>

<p>Now we have </p>

<pre><code>World -&gt; Function -&gt; List of Objects -&gt; Atoms -&gt; Display
</code></pre>

<p>And the World state could change. 
Then it is no more straightforward for the compiler to understand
when not to recompute the entire list of atoms.</p>

<p>Then to optimize we will have to make things a little less separate.
We must control the flow of atom generation.</p>

<p>Mostly the program is the same as before, but instead of providing a 
function, we will provide the list of atoms directly.</p>

<div style="display:none">

<div class="codehighlight">


<pre><code class="haskell">import YGL -- Most the OpenGL Boilerplate
import Mandel -- The 3D Mandelbrot maths

-- Centralize all user input interaction
inputActionMap :: InputMap World
inputActionMap = inputMapFromList [
     (Press 'k' , rotate xdir 5)
    ,(Press 'i' , rotate xdir (-5))
    ,(Press 'j' , rotate ydir 5)
    ,(Press 'l' , rotate ydir (-5))
    ,(Press 'o' , rotate zdir 5)
    ,(Press 'u' , rotate zdir (-5))
    ,(Press 'f' , translate xdir 0.1)
    ,(Press 's' , translate xdir (-0.1))
    ,(Press 'e' , translate ydir 0.1)
    ,(Press 'd' , translate ydir (-0.1))
    ,(Press 'z' , translate zdir 0.1)
    ,(Press 'r' , translate zdir (-0.1))
    ,(Press '+' , zoom 1.1)
    ,(Press '-' , zoom (1/1.1))
    ,(Press 'h' , resize 1.2)
    ,(Press 'g' , resize (1/1.2))
    ]
</code></pre>


</div>

</div>

<div class="codehighlight">


<pre><code class="haskell">data World = World {
      angle       :: Point3D
    , scale       :: Scalar
    , position    :: Point3D
    , box         :: Box3D
    , told        :: Time 
    -- We replace shape by cache
    , cache       :: [YObject]
    } 
</code></pre>


</div>

<div class="codehighlight">


<pre><code class="haskell">instance DisplayableWorld World where
  winTitle _ = "The YGL Mandelbulb"
  camera w = Camera {
        camPos = position w, 
        camDir = angle w,
        camZoom = scale w }
  -- We update our objects instanciation
  objects = cache
</code></pre>


</div>

<div style="display:none">

<div class="codehighlight">


<pre><code class="haskell">xdir :: Point3D
xdir = makePoint3D (1,0,0)
ydir :: Point3D
ydir = makePoint3D (0,1,0)
zdir :: Point3D
zdir = makePoint3D (0,0,1)

rotate :: Point3D -&gt; Scalar -&gt; World -&gt; World
rotate dir angleValue world = 
  world {
     angle = (angle world) + (angleValue -*&lt; dir) }

translate :: Point3D -&gt; Scalar -&gt; World -&gt; World
translate dir len world = 
  world {
    position = (position world) + (len -*&lt; dir) }

zoom :: Scalar -&gt; World -&gt; World
zoom z world = world {
    scale = z * scale world }
</code></pre>


</div>

<div class="codehighlight">


<pre><code class="haskell">main :: IO ()
main = yMainLoop inputActionMap idleAction initialWorld
</code></pre>


</div>

</div>

<p>Our initial world state is slightly changed:</p>

<div class="codehighlight">


<pre><code class="haskell">-- We initialize the world state
-- then angle, position and zoom of the camera
-- And the shape function
initialWorld :: World
initialWorld = World {
   angle = makePoint3D (30,30,0)
 , position = makePoint3D (0,0,0)
 , scale = 1.0
 , box = Box3D { minPoint = makePoint3D (-2,-2,-2)
               , maxPoint =  makePoint3D (2,2,2)
               , resolution =  0.02 }
 , told = 0
 -- We declare cache directly this time
 , cache = objectFunctionFromWorld initialWorld
 }
</code></pre>


</div>

<p>We use the <code>YGL.getObject3DFromShapeFunction</code> function directly.
This way instead of providing <code>XYFunc</code>, we provide directly a list of Atoms.</p>

<div class="codehighlight">


<pre><code class="haskell">objectFunctionFromWorld :: World -&gt; [YObject]
objectFunctionFromWorld w = [Atoms atomList]
  where atomListPositive = 
          getObject3DFromShapeFunction (shapeFunc (resolution (box w))) (box w)
        atomList = atomListPositive ++ 
          map negativeTriangle atomListPositive
        negativeTriangle (ColoredTriangle (p1,p2,p3,c)) = 
              ColoredTriangle (negz p1,negz p2,negz p3,c)
              where negz (P (x,y,z)) = P (x,y,-z)
</code></pre>


</div>

<p>We know that resize is the only world change that necessitate to 
recompute the list of atoms (triangles). 
Then we update our world state accordingly.</p>

<div class="codehighlight">


<pre><code class="haskell">resize :: Scalar -&gt; World -&gt; World
resize r world = 
  tmpWorld { cache = objectFunctionFromWorld tmpWorld }
  where 
      tmpWorld = world { box = (box world) {
              resolution = sqrt ((resolution (box world))**2 * r) }}
</code></pre>


</div>

<p>All the rest is exactly the same.</p>

<div style="display:none">

<div class="codehighlight">


<pre><code class="haskell">idleAction :: Time -&gt; World -&gt; World
idleAction tnew world = 
      world {
        angle = (angle world) + (delta -*&lt; zdir)
      , told = tnew
      }
  where 
      anglePerSec = 5.0
      delta = anglePerSec * elapsed / 1000.0
      elapsed = fromIntegral (tnew - (told world))

shapeFunc :: Scalar -&gt; Function3D
shapeFunc res x y = 
  let 
      z = findMaxOrdFor (ymandel x y) 0 1 20
  in
  if and [ findMaxOrdFor (ymandel (x+xeps) (y+yeps)) 0 1 20 &lt; 0.000001 |
              val &lt;- [res], xeps &lt;- [-val,val], yeps&lt;-[-val,val]]
      then Nothing 
      else Just (z,colorFromValue ((ymandel x y z) * 64))

colorFromValue :: Point -&gt; Color
colorFromValue n =
  let 
      t :: Point -&gt; Scalar
      t i = 0.7 + 0.3*cos( i / 10 )
  in
    makeColor (t n) (t (n+5)) (t (n+10))

findMaxOrdFor :: (Fractional a,Num a,Num b,Eq b) =&gt; 
                 (a -&gt; b) -&gt; a -&gt; a -&gt; Int -&gt; a
findMaxOrdFor _ minval maxval 0 = (minval+maxval)/2
findMaxOrdFor func minval maxval n = 
  if func medpoint /= 0 
       then findMaxOrdFor func minval medpoint (n-1)
       else findMaxOrdFor func medpoint maxval (n-1)
  where medpoint = (minval+maxval)/2

ymandel :: Point -&gt; Point -&gt; Point -&gt; Point
ymandel x y z = fromIntegral (mandel x y z 64) / 64
</code></pre>


</div>

</div>

<ul>
  <li><a href="code/06_Mandelbulb/YGL.hs"><code>YGL.hs</code></a>, the 3D rendering framework</li>
  <li><a href="code/06_Mandelbulb/Mandel.hs"><code>Mandel</code></a>, the mandel function</li>
  <li><a href="code/06_Mandelbulb/ExtComplex.hs"><code>ExtComplex</code></a>, the extended complexes</li>
</ul>

<p><a href="code/06_Mandelbulb/Mandelbulb.lhs" class="cut">06_Mandelbulb/<strong>Mandelbulb.lhs</strong> </a></p>
<hr/><div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>Generally in Haskell you need to declare a lot of import lines.
  This is something I find annoying.
  In particular, it should be possible to create a special file, Import.hs
  which make all the necessary import for you, as you generally need them all.
  I understand why this is cleaner to force the programmer not to do so,
  but, each time I do a copy/paste, I feel something is wrong.
  I believe this concern can be generalized to the lack of namespace in Haskell.<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>

                </div>
                
                

                <div id="social">
                    <div class="left">  <a href="https://twitter.com/share" class="twitter-share-button" data-via="yogsototh">Tweet</a>
       <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
     </div>
                    <div  class="left"> <div class="g-plusone" data-size="medium" data-annotation="inline" data-width="106"></div>
    <script type="text/javascript">
      (function() {
          var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
          po.src = 'https://apis.google.com/js/plusone.js';
          var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
      })();
    </script>
     </div>
                    <div class="flush"></div>
                </div>
                <div id="choixrss">
                    <a id="rss" href="http://feeds.feedburner.com/yannespositocomen">
                        Subscribe
                    </a>
                </div>
                <script type="text/javascript">
                    $(document).ready(function(){ 
                            $('#comment').hide(); 
                            $('#clickcomment').click(showComments); 
                        });
                    function showComments() {
                        $('#comment').show();
                        $('#clickcomment').fadeOut();
                    }
                    document.write('<div id="clickcomment">Comments &amp; Share</div>');
                </script>
                <div class="flush"></div>

                <div class="corps" id="comment">
                    <h2 class="first">comments</h2>
                    <noscript>
                        You must enable javascript to comment.
                    </noscript>
                    
    <script type="text/javascript">
    var idcomments_acct = 'a307f0044511ff1b5cfca573fc0a52e7';
    var idcomments_post_id = '/Scratch/en/blog/Haskell-OpenGL-Mandelbrot/';
    var idcomments_post_url = 'http://yannesposito.com/Scratch/en/blog/Haskell-OpenGL-Mandelbrot/';
    </script>
    <span id="IDCommentsPostTitle" style="display:none"></span>
    <script type='text/javascript' src='/Scratch/js/genericCommentWrapperV2.js'></script>
    
                </div>

                <div id="entete" class="corps_spaced">
                    <div id="liens">
                        <ul><li><a href="/Scratch/en/">Home</a></li>
<li><a href="/Scratch/en/blog/">Blog</a></li>
<li><a href="/Scratch/en/softwares/">Softwares</a></li>
<li><a href="/Scratch/en/about/">About</a></li></ul>
                    </div>
                    <div class="flush"></div>
                    <hr/>
                    <div id="next_before_articles">
                        <div id="previous_articles">
                            previous entries
                            
                            <div class="previous_article">
                                <a href="/Scratch/en/blog/Haskell-the-Hard-Way/"><span class="nicer">¬´</span>&nbsp;Learn Haskell Fast and Hard</a>
                            </div>
                            
                            
                            <div class="previous_article">
                                <a href="/Scratch/en/blog/Typography-and-the-Web/"><span class="nicer">¬´</span>&nbsp;Typography and the Web</a>
                            </div>
                            
                            
                            <div class="previous_article">
                                <a href="/Scratch/en/blog/Yesod-tutorial-for-newbies/"><span class="nicer">¬´</span>&nbsp;Haskell web programming</a>
                            </div>
                            
                            
                        </div>
                        <div id="next_articles">
                            next entries
                            
                            
                            
                            
                        </div>
                        <div class="flush"></div>
                    </div>
                </div>


                <div id="bottom">
                    <div>
                        <a href="https://twitter.com/yogsototh">Follow @yogsototh</a>
                    </div>
                    <div>
                        <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Copyright ¬©, Yann Esposito</a>
                    </div>
                    <div id="lastmod">
                        Created: 04/30/2012
                        Modified: 06/01/2012 
                    </div>
                    <div>
                        Entirely done with
                        <a href="http://www.vim.org">Vim</a>
                        and 
                        <a href="http://nanoc.stoneship.org">nanoc</a>
                    </div>
                </div>
                <div class="clear"></div>
            </div>
        </div>
    </body>
</html>